package main

/*
#include "nhpdevicedef.h"
*/
import "C"

import (
	"encoding/base64"
	"fmt"
	"unsafe"

	"github.com/OpenNHP/opennhp/core"
)

var devices map[string]*core.Device = make(map[string]*core.Device)
var handles map[uintptr]*core.Device = make(map[uintptr]*core.Device)

// Release the memory of the string buffer generated by NHPSDK.
//
//export nhp_free_cstring
func nhp_free_cstring(ptr *C.char) {
	C.free(unsafe.Pointer(ptr))
}

// Release the memory buffer of the nhpresult structure generated by NHPSDK.
//
//export nhp_free_NhpResult
func nhp_free_NhpResult(ptr *C.NhpResult) {
	C.free(unsafe.Pointer(ptr.errMsg))
	C.free(unsafe.Pointer(ptr))
}

// Release the memory buffer of the NhpEncryptResult structure generated by NHPSDK.
//
//export nhp_free_NhpEncryptResult
func nhp_free_NhpEncryptResult(ptr *C.NhpEncryptResult) {
	C.free(unsafe.Pointer(ptr.errMsg))
	C.free(unsafe.Pointer(ptr.packet))
	C.free(unsafe.Pointer(ptr))
}

// Release the memory buffer of the NhpDecryptResult structure generated by NHPSDK.
//
//export nhp_free_NhpDecryptResult
func nhp_free_NhpDecryptResult(ptr *C.NhpDecryptResult) {
	C.free(unsafe.Pointer(ptr.errMsg))
	C.free(unsafe.Pointer(ptr.msgId))
	C.free(unsafe.Pointer(ptr.data))
	C.free(unsafe.Pointer(ptr))
}

// Initialize the nhp_device instance
//
// Input:
// deviceType: The NHP component represented by this device: 1: nhp-agent, 2: nhp-server, 3: nhp-ac
// privateKeyBase64: Base64 encoding of the private key
//
// Return:
// NhpResult pointer:
// errCode 0: nhp device instance initialization successful
// Non-zero: nhp device instance initialization failed, errMsg: Error description
//
// Caller: Release the returned data after the call is completed, refer to the nhp_free_NhpResult function
//
//export nhp_device_init
func nhp_device_init(deviceType C.int, privateKeyBase64 string) *C.NhpResult {
	resultPtr := (*C.NhpResult)(C.malloc(C.sizeof_NhpResult))
	C.memset(unsafe.Pointer(resultPtr), 0, C.sizeof_NhpResult)

	if _, found := devices[privateKeyBase64]; found {
		resultPtr.errCode = C.ERR_NHP_DEVICE_ALREADY_CREATED
		resultPtr.errMsg = C.CString("nhp device already created with the given key")
		return resultPtr
	}

	privateKey, err := base64.StdEncoding.DecodeString(privateKeyBase64)
	if err != nil {
		resultPtr.errCode = C.ERR_NHP_CREATE_DEVICE_FAILED
		resultPtr.errMsg = C.CString("key invalid")
		return resultPtr
	}

	device := core.NewDevice(int(deviceType), privateKey, nil)

	handle := uintptr(unsafe.Pointer(device))
	devices[privateKeyBase64] = device
	handles[handle] = device
	resultPtr.handle = C.size_t(handle)
	return resultPtr
}

// Close nhp_device
// Input:
// handle: NHP device handle
//
//export nhp_device_close
func nhp_device_close(handle uintptr) {
	device, found := handles[handle]
	if found {
		delete(handles, handle)
		for k, v := range devices {
			if v == device {
				delete(devices, k)
				return
			}
		}
	}
}

// Perform NHP noise encryption on the payload data (plaintext message) and generate an NHP encrypted message
//
// Input:
// handle: NHP device handle
// msgType: NHP message type
// peerPbk: Peer public key
// peerPbkLen: Length of peer public key
// data: Plaintext payload
// dataLen: Length of plaintext payload
// params: Encryption parameters, refer to the NhpEncryptParams structure
//
// Return:
// Pointer to NhpEncryptResult, refer to the NhpEncryptResult structure
//
// Caller: After calling, release the returned data, refer to the nhp_free_NhpEncryptResult function
//
//export nhp_device_encrypt_data
func nhp_device_encrypt_data(handle uintptr, msgType C.int, peerPbk *C.uchar, peerPbkLen C.int, data *C.uchar, dataLen C.int, params C.NhpEncryptParams) *C.NhpEncryptResult {
	resultPtr := (*C.NhpEncryptResult)(C.malloc(C.sizeof_NhpEncryptResult))
	C.memset(unsafe.Pointer(resultPtr), 0, C.sizeof_NhpEncryptResult)

	device, found := handles[handle]
	if !found {
		resultPtr.errCode = C.ERR_NHP_DEVICE_NOT_INITIALIZED
		resultPtr.errMsg = C.CString("nhp device not initialized")
		return resultPtr
	}

	md := &core.MsgData{
		HeaderType:     int(msgType),
		CipherScheme:   int(params.cipherScheme),
		PeerPk:         C.GoBytes(unsafe.Pointer(peerPbk), peerPbkLen),
		Message:        C.GoBytes(unsafe.Pointer(data), dataLen),
		Compress:       params.compress != 0,
		TransactionId:  uint64(params.assignTransactionId),
		ExternalCookie: (*[core.CookieSize]byte)(unsafe.Pointer(&params.cookie)),
	}

	mad, err := device.MsgToPacket(md)
	if err != nil {
		nhpError := err.(*core.Error)
		if nhpError != nil {
			resultPtr.errCode = C.int(nhpError.ErrorNumber())
		} else {
			resultPtr.errCode = -1
		}
		resultPtr.errMsg = C.CString(err.Error())
	} else {
		resultPtr.transactionId = C.ulonglong(mad.TransactionId)
		resultPtr.packet = (*C.uchar)(C.CBytes(mad.BasePacket.Content))
		resultPtr.packetLen = C.int(len(mad.BasePacket.Content))
	}

	return resultPtr
}

// Perform NHP noise encryption on the payload data (plaintext message) and generate an NHP packet
//
// Input:
// handle: NHP device handle
// packet: NHP encrypted packet to be parsed
// packetLen: Length of the NHP encrypted packet
//
// Returns:
// Pointer to NhpDecryptResult, refer to the NhpDecryptResult structure
//
// Caller: Release the returned data after the call is complete, refer to the nhp_free_NhpDecryptResult function
//
//export nhp_device_decrypt_packet
func nhp_device_decrypt_packet(handle uintptr, packet *C.uchar, packetLen C.int, context C.NhpConnContext) *C.NhpDecryptResult {
	resultPtr := (*C.NhpDecryptResult)(C.malloc(C.sizeof_NhpDecryptResult))
	C.memset(unsafe.Pointer(resultPtr), 0, C.sizeof_NhpDecryptResult)

	device, found := handles[handle]
	if !found {
		resultPtr.errCode = C.ERR_NHP_DEVICE_NOT_INITIALIZED
		resultPtr.errMsg = C.CString("nhp device not initialized")
		return resultPtr
	}

	var cookieStore *core.CookieStore
	if context.cookieStore != nil {
		cookieStore = (*core.CookieStore)(unsafe.Pointer(context.cookieStore))
	}

	var lastPeerSendTime *int64
	if context.lastPeerSendTime != nil {
		lastPeerSendTime = (*int64)(unsafe.Pointer(context.lastPeerSendTime))
	}

	var peerPbk *[core.PublicKeySizeEx]byte
	if context.peerPbk != nil {
		peerPbk = (*[core.PublicKeySizeEx]byte)(unsafe.Pointer(context.peerPbk))
	}

	pd := &core.PacketData{
		BasePacket:             &core.Packet{Content: C.GoBytes(unsafe.Pointer(packet), packetLen)},
		ConnLastRemoteSendTime: lastPeerSendTime,
		ConnCookieStore:        cookieStore,
		ConnPeerPublicKey:      peerPbk,
	}

	ppd, err := device.PacketToMsg(pd)

	if err != nil {
		nhpError := err.(*core.Error)
		if nhpError != nil {
			resultPtr.errCode = C.int(nhpError.ErrorNumber())
		} else {
			resultPtr.errCode = -1
		}
		resultPtr.errMsg = C.CString(err.Error())
	} else {
		resultPtr.msgType = C.int(ppd.HeaderType)
		if ppd.HeaderType != core.NHP_KPL {
			resultPtr.msgTransactionId = C.ulonglong(ppd.SenderTrxId)
			resultPtr.msgId = (*C.uchar)(C.CBytes(ppd.SenderIdentity))
			resultPtr.msgIdLen = C.int(len(ppd.SenderIdentity))
			resultPtr.data = (*C.uchar)(C.CBytes(ppd.BodyMessage))
			resultPtr.dataLen = C.int(len(ppd.BodyMessage))
		}
	}

	return resultPtr
}

// Set overload mode for nhp device
//
// Input:
// handle: Handle to the NHP device
// overload: Boolean indicating whether to enable overload mode
//
// Return:
// Pointer to NhpResult, refer to NhpResult structure
//
// Caller: Release the returned data after the call, refer to nhp_free_NhpResult function
//
//export nhp_device_set_overload
func nhp_device_set_overload(handle uintptr, overload bool) *C.NhpResult {
	resultPtr := (*C.NhpResult)(C.malloc(C.sizeof_NhpResult))
	C.memset(unsafe.Pointer(resultPtr), 0, C.sizeof_NhpResult)

	device, found := handles[handle]
	if !found {
		resultPtr.errCode = C.ERR_NHP_DEVICE_NOT_INITIALIZED
		resultPtr.errMsg = C.CString("nhp device not initialized")
		return resultPtr
	}

	device.SetOverload(overload)
	return resultPtr
}

// Perform SM4 AEAD encryption
//
// Input:
// key: Key buffer
// keyLen: Key length (the first 16 bytes are used)
// nonce: Counter value buffer
// nonceLen: Counter value length (must be 12 bytes)
// plain: Plain text data
// plainLen: Plain text length
// additionalData: Additional authenticated data
// additionalDataLen: Length of additional authenticated data
//
// Return:
// Pointer to NhpEncryptResult, with the ciphertext represented by packet and packetLen
//
// Caller: After the function call, release the returned data, refer to the nhp_free_NhpEncryptResult function
//
//export nhp_sm4_aead_encrypt
func nhp_sm4_aead_encrypt(key *C.uchar, keyLen C.int, nonce *C.uchar, nonceLen C.int, plain *C.uchar, plainLen C.int, additionalData *C.uchar, additionalDataLen C.int) *C.NhpEncryptResult {
	resultPtr := (*C.NhpEncryptResult)(C.malloc(C.sizeof_NhpEncryptResult))
	C.memset(unsafe.Pointer(resultPtr), 0, C.sizeof_NhpEncryptResult)

	var aeadKey [core.SymmetricKeySize]byte
	buf := make([]byte, plainLen+16)
	copy(aeadKey[:], C.GoBytes(unsafe.Pointer(key), keyLen))

	aead := core.AeadFromKey(core.GCM_SM4, &aeadKey)
	cipher := aead.Seal(buf[:0], C.GoBytes(unsafe.Pointer(nonce), nonceLen), C.GoBytes(unsafe.Pointer(plain), plainLen), C.GoBytes(unsafe.Pointer(additionalData), additionalDataLen))
	if cipher == nil {
		resultPtr.errCode = 1
		resultPtr.errMsg = C.CString("GCM encryption failed")
		return resultPtr
	}

	resultPtr.packet = (*C.uchar)(C.CBytes(cipher))
	resultPtr.packetLen = C.int(len(cipher))
	return resultPtr
}

// Perform SM4 AEAD decryption
//
// Input:
// key: Key buffer
// keyLen: Key length (the first 16 bytes)
// nonce: Counter value buffer (must be the same as the counter value during encryption)
// nonceLen: Counter value length (must be 12 bytes)
// cipher: Ciphertext data
// cipherLen: Ciphertext length
// additionalData: Additional verification data
// additionalDataLen: Length of additional verification data
//
// Return:
// Pointer to NhpDecryptResult, plaintext is represented by data and dataLen
//
// Caller: Release the returned data after the call is complete, refer to the nhp_free_NhpEncryptResult function
//
//export nhp_sm4_aead_decrypt
func nhp_sm4_aead_decrypt(key *C.uchar, keyLen C.int, nonce *C.uchar, nonceLen C.int, cipher *C.uchar, cipherLen C.int, additionalData *C.uchar, additionalDataLen C.int) *C.NhpDecryptResult {
	resultPtr := (*C.NhpDecryptResult)(C.malloc(C.sizeof_NhpDecryptResult))
	C.memset(unsafe.Pointer(resultPtr), 0, C.sizeof_NhpDecryptResult)

	var aeadKey [core.SymmetricKeySize]byte
	buf := make([]byte, cipherLen)
	copy(aeadKey[:], C.GoBytes(unsafe.Pointer(key), keyLen))

	aead := core.AeadFromKey(core.GCM_SM4, &aeadKey)
	plain, err := aead.Open(buf[:0], C.GoBytes(unsafe.Pointer(nonce), nonceLen), C.GoBytes(unsafe.Pointer(cipher), cipherLen), C.GoBytes(unsafe.Pointer(additionalData), additionalDataLen))
	if err != nil {
		resultPtr.errCode = 1
		resultPtr.errMsg = C.CString(fmt.Sprintf("GCM decryption failed: %s", err))
		return resultPtr
	}

	resultPtr.data = (*C.uchar)(C.CBytes(plain))
	resultPtr.dataLen = C.int(len(plain))
	return resultPtr
}
